"""Lockfile for tracking downloaded AoC inputs and their hashes."""

import hashlib
from pathlib import Path

import tomli
import tomli_w

from ..paths import LOCKFILE, input_path
from ..types import Day, Year


def hash_content(content: str) -> str:
    """Compute SHA-256 hash of input content."""
    return hashlib.sha256(content.encode()).hexdigest()


def hash_file(path: Path) -> str | None:
    """Compute SHA-256 hash of a file, or None if it doesn't exist."""

    if not path.exists():
        return None

    return hash_content(path.read_text())


class Lockfile(dict[Year, dict[Day, str]]):
    """
    Tracks downloaded AoC inputs and their SHA-256 hashes.

    The lockfile is stored as TOML with the structure:
    ```toml
    [2024]
    01 = "abc123..."
    02 = "def456..."

    [2025]
    01 = "789xyz..."
    ```
    """

    def __init__(self) -> None:
        if LOCKFILE.exists():
            raw = tomli.loads(LOCKFILE.read_text())
            super().__init__(
                {
                    Year(int(year_str)): {
                        Day(int(day_str)): hash for day_str, hash in days.items()
                    }
                    for year_str, days in raw.items()
                }
            )
        else:
            super().__init__()

    def set(self, year: Year, day: Day, hash: str) -> None:
        """Set the hash for a specific input."""

        if year not in self:
            self[year] = {}

        self[year][day] = hash

    def save(self) -> None:
        """Write the lockfile to disk."""

        # Convert to string keys for TOML, sorted for consistent output
        toml_data = {
            str(year): {f"{day:02d}": hash for day, hash in sorted(days.items())}
            for year, days in sorted(self.items())
        }

        LOCKFILE.write_text(
            "# This file has been autogenerated by running `x.py inputs download`. DO NOT EDIT.\n\n"
            + tomli_w.dumps(toml_data)
        )

    def needs_download(self, year: Year, day: Day) -> bool:
        """
        Check if an input needs to be downloaded.

        Returns True if:
        - The input file doesn't exist
        - The lockfile has no entry for this input
        - The file's hash doesn't match the lockfile
        """

        stored_hash = self.get(year, {}).get(day)

        # No lockfile entry = needs download
        if stored_hash is None:
            return True

        # File doesn't exist = needs download
        file_hash = hash_file(input_path(year, day))
        if file_hash is None:
            return True

        # Hash mismatch = needs download (file was modified or corrupted)
        return file_hash != stored_hash
